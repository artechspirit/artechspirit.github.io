[{"section":"Blog","slug":"/blog/javascript-best-practice-for-writing-clean-code/","title":"JavaScript Best Practices for Writing Clean Code","description":"JavaScript is one of the most popular programming languages used for both front-end and back-end development. Writing clean and maintainable JavaScript code is crucial for building scalable applications and improving collaboration in teams. In this guide, we will explore some of the best practices for writing clean and efficient JavaScript code.","date":"September 17, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/banner-best-practice-js_hu5824173432433429692.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"271\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/banner-best-practice-js_hu1748708875315701831.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/banner-best-practice-js_hu689625563294258125.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/banner-best-practice-js_hu14975348177601862257.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"JavaScript","tags":"JavaScript, Best Practice, Clean Code","content":"1. Use const and let Instead of var One of the simplest ways to improve your JavaScript code is to stop using var. Instead, use const and let which provide block scope and prevent issues related to hoisting and reassignment.\nExample: // Bad (Using var) var name = \u0026#34;John\u0026#34;; var age = 30; // Good (Using const and let) const name = \u0026#34;John\u0026#34;; // Constant value that won’t change let age = 30; // Variable value that may change later Why? const prevents reassignment, making your code more predictable. let allows block scoping, reducing the chance of accidental redeclaration. var can lead to confusing bugs due to hoisting and function scoping. 2. Write Descriptive Variable and Function Names Avoid using single-letter or ambiguous names for variables and functions. Use names that describe the purpose or the value that they hold.\nExample: // Bad const n = 5; function a() { return n * n; } // Good const numberOfItems = 5; function calculateSquare(number) { return number * number; } Why? Descriptive names make your code more readable and maintainable. Other developers (or future you) will immediately understand what the variable or function does.\n3. Keep Functions Small and Focused Functions should perform a single task and be as short as possible. If a function is doing too many things, break it down into smaller functions.\nExample: // Bad (Too much responsibility) function processUser(user) { validateUser(user); saveUserToDatabase(user); sendWelcomeEmail(user); } // Good (Separation of concerns) function processUser(user) { validateUser(user); saveUser(user); sendWelcomeEmail(user); } function validateUser(user) { // validation logic } function saveUser(user) { // save user to database } function sendWelcomeEmail(user) { // email logic } Why? Small, focused functions are easier to test, debug, and reuse. This approach follows the Single Responsibility Principle (SRP).\n4. Avoid Repetitive Code (DRY Principle) The Don’t Repeat Yourself (DRY) principle is fundamental to writing clean code. Avoid duplicating logic by abstracting it into functions or reusable components.\nExample: // Bad (Repetitive code) const taxRate = 0.2; const priceWithTax = price * (1 + taxRate); const salaryWithTax = salary * (1 + taxRate); // Good (DRY) const taxRate = 0.2; function applyTax(amount) { return amount * (1 + taxRate); } const priceWithTax = applyTax(price); const salaryWithTax = applyTax(salary); Why? Avoiding repetition makes your code more maintainable and less prone to bugs. Changes only need to be made in one place.\n5. Use Arrow Functions Where Appropriate Arrow functions provide a shorter syntax and do not bind their own this context, which makes them especially useful in callbacks.\nExample: // Bad (Function expression) function add(a, b) { return a + b; } // Good (Arrow function) const add = (a, b) =\u0026gt; a + b; Why? Arrow functions are more concise and allow for cleaner handling of the this keyword in certain contexts, especially in React components or event handlers.\n6. Use Template Literals for String Concatenation Instead of using string concatenation with +, use template literals for clearer, more readable string interpolation.\nExample: // Bad const message = \u0026#39;Hello, \u0026#39; + name + \u0026#39;! You have \u0026#39; + notifications + \u0026#39; notifications.\u0026#39;; // Good const message = `Hello, ${name}! You have ${notifications} notifications.`; Why? Template literals make string handling easier to read and maintain, especially when dealing with multiple variables or expressions inside strings.\n7. Handle Errors Gracefully with try/catch When working with asynchronous code or potential failures (like network requests), ensure you handle errors properly using try/catch blocks or .catch() for Promises.\nExample: // Bad (No error handling) async function fetchData() { const response = await fetch(\u0026#39;https://api.example.com/data\u0026#39;); const data = await response.json(); return data; } // Good (With error handling) async function fetchData() { try { const response = await fetch(\u0026#39;https://api.example.com/data\u0026#39;); if (!response.ok) { throw new Error(\u0026#39;Failed to fetch\u0026#39;); } const data = await response.json(); return data; } catch (error) { console.error(\u0026#39;Error fetching data:\u0026#39;, error); return null; } } Why? Error handling prevents your application from crashing and provides better user experience by handling failures gracefully.\n8. Use Default Function Parameters When writing functions, set default values for parameters to make your code more robust and prevent potential issues with undefined values.\nExample: // Bad function greet(name) { return `Hello, ${name || \u0026#39;Guest\u0026#39;}!`; } // Good function greet(name = \u0026#39;Guest\u0026#39;) { return `Hello, ${name}!`; } Why? Default parameters simplify code by providing fallbacks and reducing the need for additional checks.\n9. Use Promises and async/await for Asynchronous Code When dealing with asynchronous operations, use Promises and the async/await syntax for cleaner and more readable code.\nExample: // Bad (Using callbacks) function fetchData(callback) { setTimeout(() =\u0026gt; { callback(null, { data: \u0026#39;Sample Data\u0026#39; }); }, 1000); } // Good (Using Promises with async/await) async function fetchData() { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve({ data: \u0026#39;Sample Data\u0026#39; }); }, 1000); }); } Why? Promises and async/await make asynchronous code easier to read and maintain, eliminating the \u0026ldquo;callback hell.\u0026rdquo;\n10. Avoid Mutating Data (Immutability) When working with objects or arrays, avoid mutating the original data. Instead, create copies of data to prevent side effects, especially in functional programming and React development.\nExample: // Bad (Mutating an array) const numbers = [1, 2, 3]; numbers.push(4); // Good (Using immutable methods) const numbers = [1, 2, 3]; const newNumbers = [...numbers, 4]; Why? Immutability makes your code more predictable, easier to debug, and safer in a concurrent environment.\nHere are a few more JavaScript best practices to expand on the original list:\n11. Avoid Deep Nesting Deeply nested code can become difficult to follow and maintain. Try to reduce the levels of nesting by refactoring your code, using early returns, or separating logic into smaller functions.\nExample: // Bad (Deep nesting) function processUser(user) { if (user) { if (user.isActive) { if (user.hasPaid) { return \u0026#39;User is active and has paid\u0026#39;; } } } return \u0026#39;Invalid user\u0026#39;; } // Good (Using early returns) function processUser(user) { if (!user || !user.isActive || !user.hasPaid) { return \u0026#39;Invalid user\u0026#39;; } return \u0026#39;User is active and has paid\u0026#39;; } Why? Reducing nesting makes code more readable, easier to follow, and reduces cognitive load.\n12. Use Object Destructuring for Cleaner Code Object destructuring allows you to extract properties from objects and arrays in a more concise and readable way.\nExample: // Bad const user = { name: \u0026#39;John\u0026#39;, age: 30 }; const name = user.name; const age = user.age; // Good const { name, age } = user; Why? Destructuring makes your code more concise and removes repetitive access to object properties.\n13. Use Array Methods Instead of Loops Instead of using traditional for loops, prefer higher-order functions like map(), filter(), reduce(), and forEach() for working with arrays. These methods are more declarative and expressive.\nExample: // Bad (Using for loop) const numbers = [1, 2, 3, 4]; const doubleNumbers = []; for (let i = 0; i \u0026lt; numbers.length; i++) { doubleNumbers.push(numbers[i] * 2); } // Good (Using map) const numbers = [1, 2, 3, 4]; const doubleNumbers = numbers.map(number =\u0026gt; number * 2); Why? Array methods like map and filter result in cleaner, more readable code. They also emphasize immutability, since they return new arrays instead of modifying the original one.\n14. Use Strict Equality (===) Always use === (strict equality) instead of == (loose equality) to avoid unexpected type coercion.\nExample: // Bad if (1 == \u0026#39;1\u0026#39;) { console.log(\u0026#39;Equal\u0026#39;); // true, but type coercion happens } // Good if (1 === \u0026#39;1\u0026#39;) { console.log(\u0026#39;Equal\u0026#39;); // false, since types are not the same } Why? Strict equality avoids implicit type conversion, reducing bugs caused by comparing different data types.\n15. Comment Your Code When Necessary While clean code is often self-explanatory, sometimes comments are necessary to explain the why behind complex logic or certain decisions.\nExample: // Bad (No comments for complex logic) const calculateDiscount = (price) =\u0026gt; price \u0026gt; 100 ? price * 0.9 : price; // Good (Commenting the logic) const calculateDiscount = (price) =\u0026gt; { // If the price is above 100, apply a 10% discount return price \u0026gt; 100 ? price * 0.9 : price; }; Why? Comments can explain the reasoning behind decisions or clarify complex logic. However, avoid over-commenting or explaining obvious code.\n16. Use Constants for Magic Numbers Avoid hardcoding numbers (magic numbers) directly in your code. Instead, store them in constants with descriptive names.\nExample: // Bad (Magic number) function calculateDiscount(price) { return price * 0.07; // What is 0.07? } // Good (Using a named constant) const TAX_RATE = 0.07; function calculateDiscount(price) { return price * TAX_RATE; } Why? Using named constants makes your code more readable and easier to maintain, especially when numbers have specific meanings or are used in multiple places.\n17. Use null or undefined Appropriately Be mindful of when to use null and undefined. Use null to explicitly define an \u0026ldquo;empty\u0026rdquo; value, while undefined indicates the absence of a value (e.g., uninitialized variables).\nExample: // Bad let name = undefined; // It\u0026#39;s better to use null for explicitly empty values // Good let name = null; // Indicates an intentional empty value Why? Understanding the difference between null and undefined helps avoid unintended bugs and makes code more semantically meaningful.\n18. Refactor Long switch Statements Avoid using long switch statements when there are cleaner alternatives like objects or dictionaries for lookup.\nExample: // Bad (Using switch) function getRole(role) { switch (role) { case \u0026#39;admin\u0026#39;: return \u0026#39;Administrator\u0026#39;; case \u0026#39;user\u0026#39;: return \u0026#39;Regular User\u0026#39;; case \u0026#39;guest\u0026#39;: return \u0026#39;Guest\u0026#39;; default: return \u0026#39;Unknown Role\u0026#39;; } } // Good (Using object lookup) const roles = { admin: \u0026#39;Administrator\u0026#39;, user: \u0026#39;Regular User\u0026#39;, guest: \u0026#39;Guest\u0026#39;, }; function getRole(role) { return roles[role] || \u0026#39;Unknown Role\u0026#39;; } Why? Object lookups are more readable and easier to maintain than long switch statements.\n19. Avoid Side Effects in Functions A function should, whenever possible, avoid mutating variables outside of its scope (side effects). Pure functions that only rely on their inputs are easier to test and debug.\nExample: // Bad (Side effect) let counter = 0; function increment() { counter++; } // Good (Pure function) function increment(counter) { return counter + 1; } Why? Pure functions are predictable and less prone to introducing bugs, making them a cornerstone of functional programming.\n20. Use ESLint and Prettier To ensure consistent code formatting and catch potential issues early, use tools like ESLint and Prettier. These tools can be integrated into your workflow to enforce clean code standards automatically.\nExample: ESLint: Helps identify and fix common code issues and enforces coding standards. Prettier: Automatically formats code for consistency and readability. Why? These tools help maintain code quality, consistency, and prevent potential bugs early in the development process.\nHere are a few more advanced JavaScript best practices that can further improve your clean coding approach:\n21. Use async/await Over then() for Promises Using async/await improves readability and simplifies chaining of promises. It also helps avoid callback hell.\nExample: // Bad (Using .then) fetchUserData() .then((user) =\u0026gt; fetchUserPosts(user.id)) .then((posts) =\u0026gt; displayPosts(posts)) .catch((error) =\u0026gt; handleError(error)); // Good (Using async/await) async function fetchAndDisplayUserData() { try { const user = await fetchUserData(); const posts = await fetchUserPosts(user.id); displayPosts(posts); } catch (error) { handleError(error); } } Why? async/await is more readable and makes error handling with try/catch clearer compared to using .then() and .catch() for chaining promises.\n22. Avoid Modifying Function Parameters Changing function parameters within a function can introduce bugs, especially when passing objects or arrays by reference. Always treat function parameters as immutable and return new values instead of modifying the original ones.\nExample: // Bad (Modifying parameter) function updateUser(user) { user.isAdmin = true; return user; } // Good (Creating a new object) function updateUser(user) { return { ...user, isAdmin: true }; } Why? Keeping function parameters immutable prevents unexpected side effects, especially when working with shared data in a complex application.\n23. Avoid Using the new Keyword for Object Creation Instead of using the new keyword to create objects, consider using factory functions or classes to handle object instantiation. This approach is cleaner, avoids issues with this context, and is more predictable.\nExample: // Bad (Using new with function constructor) function Person(name) { this.name = name; } const person = new Person(\u0026#39;John\u0026#39;); // Good (Using class or factory function) class Person { constructor(name) { this.name = name; } } const person = new Person(\u0026#39;John\u0026#39;); Why? Using classes or factory functions makes your code more consistent and easier to work with, especially for object creation and inheritance.\n24. Use Functional Programming Principles Incorporate functional programming principles like pure functions, higher-order functions, and immutability. Avoid mutating state directly and use methods like map, filter, and reduce to process data without side effects.\nExample: // Bad (Imperative, mutating array) const numbers = [1, 2, 3, 4]; for (let i = 0; i \u0026lt; numbers.length; i++) { numbers[i] *= 2; } // Good (Declarative, using map) const numbers = [1, 2, 3, 4]; const doubled = numbers.map((n) =\u0026gt; n * 2); Why? Functional programming leads to more predictable, testable, and maintainable code by emphasizing immutability and reducing side effects.\n25. Use Optional Chaining and Nullish Coalescing Optional chaining (?.) allows you to safely access deeply nested properties, avoiding runtime errors when a property doesn\u0026rsquo;t exist. Nullish coalescing (??) provides a default value only when null or undefined is encountered.\nExample: // Bad const user = {}; const city = user \u0026amp;\u0026amp; user.address \u0026amp;\u0026amp; user.address.city; // Good (Using optional chaining and nullish coalescing) const user = {}; const city = user?.address?.city ?? \u0026#39;Unknown\u0026#39;; Why? Optional chaining and nullish coalescing simplify your code and prevent runtime errors when accessing potentially null or undefined values.\n26. Use for...of and for...in Instead of forEach When Necessary Although .forEach() is a common way to iterate through arrays, for...of provides greater flexibility, such as allowing the use of break or continue statements.\nExample: // Bad (Using forEach without control flow) [1, 2, 3, 4].forEach((num) =\u0026gt; { if (num === 3) { return; // This doesn\u0026#39;t break out of the loop, just skips the current iteration } console.log(num); }); // Good (Using for...of with break/continue) for (const num of [1, 2, 3, 4]) { if (num === 3) continue; // Skips this iteration console.log(num); } Why? for...of allows greater control in loops with features like break and continue, which cannot be used with .forEach().\n27. Prefer Named Exports Over Default Exports Using named exports makes it easier to identify and import exactly what you need from a module. It also helps avoid issues with default exports when refactoring code.\nExample: // Bad (Using default export) export default function calculateTotal() { //... } // Good (Using named export) export function calculateTotal() { //... } Why? Named exports provide better auto-completion in editors and prevent name collisions, making it clearer which module you are importing.\n28. Avoid Using eval() Using eval() can be dangerous as it executes arbitrary code, making your code vulnerable to attacks like code injection. Avoid it in all circumstances.\nExample: // Bad (Using eval) const code = \u0026#39;console.log(\u0026#34;Hello World\u0026#34;)\u0026#39;; eval(code); // This is dangerous and prone to security issues // Good (Avoid eval) const code = \u0026#39;console.log(\u0026#34;Hello World\u0026#34;)\u0026#39;; // Manually execute or refactor the code without eval Why? eval() can introduce security vulnerabilities and lead to unpredictable behavior. Modern JavaScript rarely, if ever, requires eval() to solve a problem.\n29. Use .bind() or Arrow Functions to Preserve this in Callbacks In event handlers or callbacks, this can refer to different contexts. Use .bind() or arrow functions to explicitly bind this to the appropriate context.\nExample: // Bad (Incorrect use of this in callback) class MyComponent { handleClick() { console.log(this); // `this` will not refer to the class instance } render() { return \u0026lt;button onClick={this.handleClick}\u0026gt;Click me\u0026lt;/button\u0026gt;; } } // Good (Using arrow function or bind to preserve this) class MyComponent { handleClick = () =\u0026gt; { console.log(this); // `this` refers to the class instance } render() { return \u0026lt;button onClick={this.handleClick}\u0026gt;Click me\u0026lt;/button\u0026gt;; } } Why? Using .bind() or arrow functions ensures that this refers to the correct context, avoiding potential bugs in event handlers or callbacks.\n30. Use Immutable Data Structures When Possible In certain contexts (e.g., React or Redux), using immutable data structures like Immutable.js or native JavaScript methods that don\u0026rsquo;t mutate data (map, filter, reduce) helps prevent unintended side effects and ensures data consistency.\nExample: // Bad (Mutating original array) const numbers = [1, 2, 3]; numbers.push(4); // Good (Using immutable approach) const numbers = [1, 2, 3]; const newNumbers = [...numbers, 4]; Why? Immutability ensures data is not inadvertently modified in ways that affect other parts of the application, leading to more predictable and reliable code.\nConclusion By applying these advanced best practices in your JavaScript code, you\u0026rsquo;ll be able to write clean, efficient, and maintainable applications, whether in React.js, Node.js, or any other environment. These techniques help streamline the development process, improve code readability, and reduce the chances of bugs and issues down the line.\n"},{"section":"Blog","slug":"/blog/the-most-effective-and-simple-way-to-implement-rtk-in-nextjs/","title":"The Most Effective and Simple Way to Implement Redux Toolkit Query in Next.js with CRUD Operations","description":"Redux Toolkit Query (RTK Query) is an advanced data fetching and caching tool that integrates seamlessly with Redux, making it a great choice for managing server state. Combined with Next.js’s App Router and Tailwind CSS, you can create a robust, scalable, and beautifully styled application with minimal effort.","date":"September 15, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog-post-2_hu12956224015231812805.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"236\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog-post-2_hu12956224015231812805.webp';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog-post-2_hu13306885116178179341.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog-post-2_hu13306885116178179341.webp';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"JavaScript, Frontend Development","tags":"html, css, JavaScript, Redux Toolkit Query, React Hook, Next.js","content":"When building modern web applications, efficiency and simplicity are crucial. Redux Toolkit Query (RTK Query) simplifies data fetching and caching, making it an excellent choice for managing server state. Coupled with Next.js’s App Router and Tailwind CSS, you can create a scalable, well-styled application with minimal effort.\nIn this blog post, we’ll demonstrate how to implement RTK Query in a Next.js project using the App Router, perform CRUD operations with the FakeStore API, and style the application with Tailwind CSS. This guide is designed to be practical, modular, and easy to follow, ensuring clean and maintainable code.\nBackground Next.js is a powerful React framework that supports server-side rendering, static site generation, and more. Redux Toolkit Query is part of Redux Toolkit, designed to simplify data fetching and caching. Tailwind CSS is a utility-first CSS framework that makes it easy to create responsive and customizable designs.\nThe FakeStore API provides a straightforward way to simulate interactions with a store, making it ideal for our CRUD operations.\nStep-by-Step Guide 1. Setting Up the Project First, set up a Next.js project with JavaScript and install the necessary dependencies:\nnpx create-next-app my-app cd my-app npm install @reduxjs/toolkit react-redux daisyui npm install tailwindcss@latest postcss@latest autoprefixer@latest npx tailwindcss init -p Configure Tailwind CSS by editing tailwind.config.js:\nmodule.exports = { content: [ \u0026#39;./app/**/*.{js,jsx}\u0026#39;, \u0026#39;./components/**/*.{js,jsx}\u0026#39;, \u0026#39;./pages/**/*.{js,jsx}\u0026#39;, ], theme: { extend: {}, }, plugins: [require(\u0026#39;daisyui\u0026#39;)], }; Add Tailwind CSS to styles/globals.css:\n@tailwind base; @tailwind components; @tailwind utilities; 2. Setting Up Redux Toolkit Query Create an API slice using RTK Query. This will serve as our interface to the FakeStore API.\nCreate app/store/api.js:\nimport { createApi, fetchBaseQuery } from \u0026#39;@reduxjs/toolkit/query/react\u0026#39;; export const fakeStoreApi = createApi({ reducerPath: \u0026#39;fakeStoreApi\u0026#39;, baseQuery: fetchBaseQuery({ baseUrl: \u0026#39;https://fakestoreapi.com\u0026#39; }), endpoints: (builder) =\u0026gt; ({ getProducts: builder.query({ query: () =\u0026gt; \u0026#39;/products\u0026#39;, }), getProductById: builder.query({ query: (id) =\u0026gt; `/products/${id}`, }), addProduct: builder.mutation({ query: (product) =\u0026gt; ({ url: \u0026#39;/products\u0026#39;, method: \u0026#39;POST\u0026#39;, body: product, }), }), updateProduct: builder.mutation({ query: ({ id, ...product }) =\u0026gt; ({ url: `/products/${id}`, method: \u0026#39;PUT\u0026#39;, body: product, }), }), deleteProduct: builder.mutation({ query: (id) =\u0026gt; ({ url: `/products/${id}`, method: \u0026#39;DELETE\u0026#39;, }), }), }), }); export const { useGetProductsQuery, useGetProductByIdQuery, useAddProductMutation, useUpdateProductMutation, useDeleteProductMutation, } = fakeStoreApi; 3. Setting Up Redux Store Create the Redux store and configure it in app/store/index.js:\nimport { configureStore } from \u0026#39;@reduxjs/toolkit\u0026#39;; import { fakeStoreApi } from \u0026#39;./api\u0026#39;; export const store = configureStore({ reducer: { [fakeStoreApi.reducerPath]: fakeStoreApi.reducer, }, middleware: (getDefaultMiddleware) =\u0026gt; getDefaultMiddleware().concat(fakeStoreApi.middleware), }); Provide the store in app/layout.js:\nimport { Provider } from \u0026#39;react-redux\u0026#39;; import { store } from \u0026#39;./store\u0026#39;; export default function RootLayout({ children }) { return ( \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head /\u0026gt; \u0026lt;body\u0026gt; \u0026lt;Provider store={store}\u0026gt;{children}\u0026lt;/Provider\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ); } 4. Implementing CRUD Pages Create pages for listing, viewing, adding, and editing products.\nList Products (app/products/page.js): import { useGetProductsQuery } from \u0026#39;../store/api\u0026#39;; import Link from \u0026#39;next/link\u0026#39;; export default function ProductsPage() { const { data, error, isLoading } = useGetProductsQuery(); if (isLoading) return \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt;; if (error) return \u0026lt;p\u0026gt;Error loading products\u0026lt;/p\u0026gt;; return ( \u0026lt;div className=\u0026#34;container mx-auto p-4\u0026#34;\u0026gt; \u0026lt;h1 className=\u0026#34;text-2xl font-bold mb-4\u0026#34;\u0026gt;Products\u0026lt;/h1\u0026gt; \u0026lt;div className=\u0026#34;grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6\u0026#34;\u0026gt; {data?.map((product) =\u0026gt; ( \u0026lt;div key={product.id} className=\u0026#34;border p-4 rounded\u0026#34;\u0026gt; \u0026lt;h2 className=\u0026#34;text-lg font-semibold\u0026#34;\u0026gt;{product.title}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;${product.price}\u0026lt;/p\u0026gt; \u0026lt;Link href={`/products/${product.id}`}\u0026gt; \u0026lt;button className=\u0026#34;mt-2 bg-blue-500 text-white py-1 px-2 rounded\u0026#34;\u0026gt;View\u0026lt;/button\u0026gt; \u0026lt;/Link\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } Product Details (app/products/[id]/page.js): import { useGetProductByIdQuery } from \u0026#39;../../store/api\u0026#39;; import { useRouter } from \u0026#39;next/router\u0026#39;; export default function ProductDetailPage({ params }) { const { id } = params; const { data, error, isLoading } = useGetProductByIdQuery(id); if (isLoading) return \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt;; if (error) return \u0026lt;p\u0026gt;Error loading product\u0026lt;/p\u0026gt;; return ( \u0026lt;div className=\u0026#34;container mx-auto p-4\u0026#34;\u0026gt; \u0026lt;h1 className=\u0026#34;text-2xl font-bold\u0026#34;\u0026gt;{data?.title}\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;mt-2\u0026#34;\u0026gt;{data?.description}\u0026lt;/p\u0026gt; \u0026lt;p className=\u0026#34;mt-2 text-lg font-semibold\u0026#34;\u0026gt;${data?.price}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Add Product (app/products/add/page.js): import { useState } from \u0026#39;react\u0026#39;; import { useAddProductMutation } from \u0026#39;../../store/api\u0026#39;; export default function AddProductPage() { const [addProduct] = useAddProductMutation(); const [formData, setFormData] = useState({ title: \u0026#39;\u0026#39;, price: \u0026#39;\u0026#39;, description: \u0026#39;\u0026#39;, image: \u0026#39;\u0026#39;, category: \u0026#39;\u0026#39;, }); const handleChange = (e) =\u0026gt; { setFormData({ ...formData, [e.target.name]: e.target.value }); }; const handleSubmit = async (e) =\u0026gt; { e.preventDefault(); await addProduct(formData); }; return ( \u0026lt;form onSubmit={handleSubmit} className=\u0026#34;container mx-auto p-4\u0026#34;\u0026gt; \u0026lt;h1 className=\u0026#34;text-2xl font-bold mb-4\u0026#34;\u0026gt;Add New Product\u0026lt;/h1\u0026gt; \u0026lt;input name=\u0026#34;title\u0026#34; value={formData.title} onChange={handleChange} placeholder=\u0026#34;Title\u0026#34; className=\u0026#34;border p-2 w-full mb-4\u0026#34; /\u0026gt; {/* Repeat for other fields */} \u0026lt;button type=\u0026#34;submit\u0026#34; className=\u0026#34;bg-green-500 text-white py-2 px-4 rounded\u0026#34;\u0026gt; Submit \u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ); } Edit Product (app/products/[id]/edit/page.js): import { useState, useEffect } from \u0026#39;react\u0026#39;; import { useRouter } from \u0026#39;next/router\u0026#39;; import { useGetProductByIdQuery, useUpdateProductMutation } from \u0026#39;../../store/api\u0026#39;; export default function EditProductPage({ params }) { const { id } = params; const { data, error, isLoading } = useGetProductByIdQuery(id); const [updateProduct] = useUpdateProductMutation(); const [formData, setFormData] = useState({ title: \u0026#39;\u0026#39;, price: \u0026#39;\u0026#39;, description: \u0026#39;\u0026#39;, image: \u0026#39;\u0026#39;, category: \u0026#39;\u0026#39;, }); useEffect(() =\u0026gt; { if (data) { setFormData(data); } }, [data]); const handleChange = (e) =\u0026gt; { setFormData({ ...formData, [e.target.name]: e.target.value }); }; const handleSubmit = async (e) =\u0026gt; { e.preventDefault(); await updateProduct({ id, ...formData }); }; if (isLoading) return \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt;; if (error) return \u0026lt;p\u0026gt;Error loading product\u0026lt;/p\u0026gt;; return ( \u0026lt;form onSubmit={handleSubmit} className=\u0026#34;container mx-auto p-4\u0026#34;\u0026gt; \u0026lt;h1 className=\u0026#34;text-2xl font-bold mb-4\u0026#34;\u0026gt;Edit Product\u0026lt;/h1\u0026gt; \u0026lt;input name=\u0026#34;title\u0026#34; value={formData.title} onChange={handleChange} placeholder =\u0026#34;Title\u0026#34; className=\u0026#34;border p-2 w-full mb-4\u0026#34; /\u0026gt; {/* Repeat for other fields */} \u0026lt;button type=\u0026#34;submit\u0026#34; className=\u0026#34;bg-blue-500 text-white py-2 px-4 rounded\u0026#34;\u0026gt; Update \u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ); } Delete Product (Button in ProductDetailPage): Add a delete button in the product detail page:\nimport { useDeleteProductMutation } from \u0026#39;../../store/api\u0026#39;; export default function ProductDetailPage({ params }) { const { id } = params; const { data, error, isLoading } = useGetProductByIdQuery(id); const [deleteProduct] = useDeleteProductMutation(); const handleDelete = async () =\u0026gt; { await deleteProduct(id); // Redirect or show a success message }; if (isLoading) return \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt;; if (error) return \u0026lt;p\u0026gt;Error loading product\u0026lt;/p\u0026gt;; return ( \u0026lt;div className=\u0026#34;container mx-auto p-4\u0026#34;\u0026gt; \u0026lt;h1 className=\u0026#34;text-2xl font-bold\u0026#34;\u0026gt;{data?.title}\u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;mt-2\u0026#34;\u0026gt;{data?.description}\u0026lt;/p\u0026gt; \u0026lt;p className=\u0026#34;mt-2 text-lg font-semibold\u0026#34;\u0026gt;${data?.price}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleDelete} className=\u0026#34;mt-4 bg-red-500 text-white py-2 px-4 rounded\u0026#34; \u0026gt; Delete \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 5. Final Touches and Best Practices Reusability: Create reusable components for forms and buttons to avoid code duplication. Error Handling: Implement robust error handling to improve user experience and provide feedback. Optimistic Updates: Consider using optimistic updates for a smoother user experience when performing mutations. Conclusion Integrating Redux Toolkit Query with Next.js using the App Router and combining it with Tailwind CSS provides a powerful and elegant solution for managing server state and building user interfaces. By following this guide, you’ll be able to create a highly efficient and maintainable CRUD application with minimal boilerplate code.\nFeel free to experiment with the provided code and customize it further to suit your needs. Happy coding!\n"},{"section":"Blog","slug":"/blog/the-ultimate-guide-to-learning-html-css-javascript/","title":"The Ultimate Guide to Learning HTML, CSS, and JavaScript (ES2015+)","description":"Discover the ultimate guide to mastering HTML, CSS, and JavaScript (ES2015+) with comprehensive tutorials and video resources from FreeCodeCamp. Build a strong foundation in web development with practical projects and expert guidance.","date":"September 1, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_hu3325241596321067976.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"236\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_hu12999451053124933890.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_hu2707740879019320827.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_hu11447808651278550042.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"JavaScript, Frontend Development, Node.js","tags":"html, css, JavaScript","content":"Whether you\u0026rsquo;re starting your web development journey or looking to refresh your skills, understanding the fundamentals of HTML, CSS, and JavaScript is crucial. This guide will take you through each of these core technologies, with valuable resources from FreeCodeCamp to help you learn effectively.\n1. HTML: The Structure of the Web HTML (HyperText Markup Language) forms the backbone of web pages, providing structure and meaning to your content. Here’s how to get started:\nBasics of HTML Introduction to HTML: Learn the basic syntax and structure of HTML, including elements, tags, and attributes.\nFreeCodeCamp: HTML and HTML5 HTML5 New Elements: Understand the new elements introduced in HTML5, such as \u0026lt;header\u0026gt;, \u0026lt;footer\u0026gt;, and \u0026lt;article\u0026gt;.\nFreeCodeCamp: HTML5 Video Tutorial FreeCodeCamp: HTML Full Course This comprehensive video covers the basics of HTML and HTML5 in detail. 2. CSS: Styling Your Web Pages CSS (Cascading Style Sheets) is used to control the look and feel of a web page. It allows you to apply styles like colors, fonts, and layouts.\nBasics of CSS Introduction to CSS: Learn how to apply styles to HTML elements, including color, typography, and layout.\nFreeCodeCamp: Basic CSS Responsive Design: Understand how to make your web pages responsive and look good on various devices.\nFreeCodeCamp: Responsive Web Design Video Tutorial FreeCodeCamp: CSS Full Course This video provides an in-depth overview of CSS, including advanced styling techniques. 3. JavaScript (ES2015 and Beyond): Making Your Web Pages Interactive JavaScript is a powerful scripting language that enables dynamic content and interactive features on web pages. ES2015 (also known as ES6) and later versions introduced significant improvements to the language.\nJavaScript Basics Introduction to JavaScript: Learn the fundamental concepts of JavaScript, including variables, data types, and operators.\nFreeCodeCamp: Basic JavaScript ES2015 Features: Explore the new features introduced in ES2015, such as arrow functions, classes, and template literals.\nFreeCodeCamp: ES6 Video Tutorial FreeCodeCamp: JavaScript ES6 Full Course This video covers the essential ES6 features and modern JavaScript practices. 4. Combining HTML, CSS, and JavaScript To create a fully functional web page, you need to integrate HTML, CSS, and JavaScript. Practice combining these technologies by building simple projects.\nProject Ideas Build a Personal Portfolio: Create a personal website showcasing your skills and projects. Develop a To-Do List App: Implement a simple task manager using HTML, CSS, and JavaScript. Video Tutorial FreeCodeCamp: Full Web Development Course This comprehensive course covers HTML, CSS, and JavaScript, providing a complete overview of web development. 5. Practice and Projects Hands-on practice is key to mastering these technologies. Use the following resources to apply what you’ve learned:\nFreeCodeCamp: Projects Work on various projects to reinforce your understanding and build your portfolio. Conclusion Mastering HTML, CSS, and JavaScript is essential for any web developer. By following this guide and utilizing the FreeCodeCamp resources, you’ll build a strong foundation and be well on your way to creating stunning and interactive web applications. Happy coding!\n"}]